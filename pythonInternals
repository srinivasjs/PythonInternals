When we execute 
>>>a = "Python Internals"
the following takes place internally :
1. Lexing
2. Parsing
3. Compiling
4. Interpreter

Lexing  :  Breaking lines of code into Tokens
Parsing  :  The parser takes those tokens and generates a structure that shows their relationship to each other (in this case, an Abstract Syntax Tree).
Compiling  :   The compiler then takes the AST(Abstract Syntax Tree) and turns it into one (or more) code objects.
Interpreter  :  The interpreter takes each code object executes the code it represents.

Before diving deep into Interpreter, let us look at Function objects, Code objects and Bytecode.

Function Objects:

Functions are first-class objects in python meaning Fuctions in python are also Objects that behaves exactly similar to instantiated objects in python . 

>>> def add(a):
...     d = 3
...     return d + a
...
>>> add
<function add at 0x137bf6ab0>

foo can be passed as function arguments to other functions and later called upon . We could also bind it to a new name.
new_foo = foo
and can be called as new_foo()

Code Objects:

>>> def add(a):
...     d = 3
...     return d + a
...
>>> add
<function add at 0x137bf6ab0>
>>> add.func_code
<code object add at 0x137bf6ab0, file "<stdin>", line 1>

The above code object is generated by Compiler and interpreted by interpreter . 
>>> add.func_code.co_varnames
('d', 'a')
>>> add.func_code.co_consts
(None, 3)
>>> foo.func_code.co_argcount
1
co_argcount indicates the number of arguments the function "add" takes in

Lets, now see bytecode :

>>> add.func_code.co_code
'd\x01\x00}\x01\x00|\x01\x00|\x00\x00\x17S'

Python Byte code and Python Code Object are not the same !!! as shown above

Bytecode are instructions to the Interpreter
The interpreter will loop through each byte, look up what it should do for each one, and then do that thing.


